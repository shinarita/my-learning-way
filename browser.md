## 浏览器

### 浏览器的进程
1. 浏览器进程(browser process)
    1. UI线程：绘制按钮和输入区域
    2. 网络线程：发送网络请求并接收数据
    3. 存储线程：控制文件的读取
2.  

### 浏览器的一次url查询过程
1. 处理用户输入
    1. UI线程：Chrome地址栏同样也是搜索输入栏，所以UI线程首先解析判断，是URL则发送给查询的网址，是搜索查询则发送给搜索引擎
2. 处理响应
    2. 网络线程：用户点击enter后，UI线程会初始化一个网络调用。网络线程通过DNS查询ip地址并建立TLS连接。如果收到301的http响应，网络线程会通知UI线程服务器请求重定向，那么UI线程会初始化另一个URL请求。
    1. 安全检查：如果这个域名和内容已知是有危害的，那么网络进程会现在一个警告页面。如果是跨域请求，会发生跨域拦截防止敏感跨域数据进入渲染进程。
    2. 阅读content-type。如果是zip或其他文件，代表是下载请求，网络线程会传递数据给下载管理器。如果是html文件，网络线程会告知UI线程，UI线程会寻找一个渲染进程来渲染页面。
    3. 网络线程告知UI线程

### Jank
用于描述页面渲染的流利程度。如果一个页面对操作表现出反应缓慢或卡顿就成为Jank。
原因：1）JS操作太长时间，浏览器无法在16.67s内创建新帧；2）某个元素的css属性改变，引起浏览器重计算和重绘整个页面。
措施：1）浏览器渲染流程：calculate=》layout=》paint=》composite，尽量使用只触发重新composite的css属性，比如优先使用transform代替top和left属性。
> 浏览器并不需要执行所有的步骤，每一帧只执行需要的步骤。所以提交性能最好的办法就是减少执行的步骤。

### css解析会JS的和DOM解析的影响
1. css不会阻塞DOM树的解析，会阻止DOM树的渲染：DOM的渲染必须结合CSS
2. css会阻塞后面js的执行
3. 减少白屏的方法：使用CDN；对css进行压缩；合理使用缓存；减少http请求数

### sessionId和token的区别
1. 存储：sessionId同时存储在服务器（数据库）和客户端（cookie）；令牌只存储在客户端，某种程度上是无状态的。
2. 验证：验证cookie中的sessionId时，需要查询数据库；对于令牌，只需要验证令牌的签名（时间换空间）。
3. 多域：cookie只在单域中可见；令牌是手工添加的，可发送到任何目的地，可在跨域中使用。
4. 撤销：sessionId可以在服务器上删除，所以可以集中撤销；令牌只能在客户端删除。如果需要“在所有设备上签出”这种功能，选择sessionId更合适。
5. 漏洞：由于cookie是浏览器自动包含的，所以会话容易受到CSRF的影响。由于令牌通常保存在本地，所以更容易被xss窃取。

### XSS
1. 代码注入，第三方可以在你的网站上执行他们不应该执行的代码。
2. 对于token，无法拒绝本地代码以及第三方代码访问它；cookie通过设置httpOnly可以禁止js访问，所以第三方js无法劫持。

### CSRF
1. 操作用户向目前已认证通过的应用程序提交非预期请求的攻击，因为认证信息（cookie）自动包含在被害者的浏览器请求中。
2. 预防策略：
    1. 将用户认证cookie的SameSite设置为lax，只在get和head的安全请求中携带cookie。
    2. 在所有更改状态的请求上禁用cors。
    3. 在api请求中强制使用content-type：application/json，在服务器上仔细检查报头。
3. 执行策略：CSRF令牌，服务器为每个响应随机生成一个csrf令牌，并将samesite属性设为strict，意味着客户端只能包含源于这里的请求。发出请求后，客户端将令牌设置为x-csrf-token头部中，在服务器上检测header值与cookie值是否一致来确保请求的有效性。