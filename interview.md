# 记录我的面试

## 3/17

### 1. 微前端

目的：云计算项目中各种组件的迭代版本不一致；POC 项目，客户定制化版本的需要。

思想：微前端思想来源于微服务，将一个大的应用拆分成不同的子应用，子应用可以独立开发、独立部署，可使用不同的技术栈。单页面应用中，会维护一张路由注册表，每个路由对应页面组件的 url。切换路由时，如果是新页面则动态获取路由对应的 js 脚本并执行渲染；如果是已访问过，则从缓存中获取已缓存的页面方法，执行并渲染。

single-spa 应用分为两类：基座应用和子应用。基座应用会维护一个路由注册表，每个路由对应一个子应用。切换路由就会动态渲染对应的子应用。

> 需要的工作：

        1. 改造项目，增加基座应用，维护路由。
        2. 改造子项目，增加生命周期函数bootstrap、mount、unmount。

> 我的工作：

       1. 合并login模块，改造login模块，增加启动、卸载等方法，保存登录态。
       2. 使用nodejs编写自动化按需构建脚本，可以选择需要打包的子应用。
       3. 开发自定义loader。

> iframe 缺点

       1. 用户体验不好，切换应用时浏览器需重新加载页面
       2. UI不同步，DOM结构不共享，浏览器状态不一致
       3. 全局上下文完全隔离，通信不同步

> qiankun 的缺点，可以独立打包一些类库吗。相比 iframe 的缺点<br>

       1.相同的资源重复加载
       2.启动应用时必须要启动基座应用

### 2. 跨域

> 定义

指浏览器遵循同源策略，限制脚本内发起的跨域 http 请求，具体指域名、协议、端口号完全相同才是同源。

> 方法

       1. jsonp，缺点是只能get，易受到xss攻击
       2. CORS，跨域资源共享。跨域请求时浏览器会带上origin请求头，后端接收后会加上access-control-allow-origin，浏览器会判断是否继续响应。缺点：忽略cookie。简单请求直接发送，非简单请求会先使用options方法发送一个预检请求，符合条件后再发送正式请求。
       3. nginx反向代理

### 3. http code

       1. 100：continue，继续请求
       2. 101：切换协议，如http新版本、websocket
       3. 200：ok
       4. 301：永久移动，会返回新的url
       5. 304：未修改
       6. 400：语法错误
       7. 401：未授权
       8. 403：拒绝服务
       9. 404：未找到
       10. 500：服务器内部错误
       11. 502：网关错误
       12. 503：服务不可用
       13. 504：网关超时

### 4. websocke 协议

> 定义

因为 http 单向请求的特点，一般通过轮询来连续获取服务端的信息。而 websocket 是 H5 的一种新协议，实现浏览器和客户端全双工通信，同时允许跨域通信。

> 与 http 关系

       1. 也建立在tcp协议之上。
       2. 与http有良好的兼容性，默认端口也是80和443，握手阶段采取http协议，因此不容易被屏蔽，能通过各种http代理服务器。
       3. 没有同源限制，可与任务服务器通信。
       4. 加密使用wss协议标识符，服务器网址就是url

### 5. metadata

元数据，提供关于页面的元数据。在 html 中处于 head 区域，用于页面的说明、关键字和其他元数据。有 name、http-equiv、content、scheme 属性，name 指定 meta 元素的类型，content 指定实际内容。一般有 keywords、description、author、viewport、robots、copyright。

### 6. 原型

> 定义

js 是一种基于原型的语言，是指每个对象都有一个原型对象。对象以原型对象为模板，继承方法和属性。原型对象也可以拥有原型，并继承属性和方法，一层一层直到 Object.prototype，这就是原型链。当我们查找一个对象的属性时，首先查找本身，如果没有，就顺着原型链查找其原型对象上的属性，如果最终没有就是 undefined。
js 中每个函数都有 prototype 这个属性，当作为构造函数创建新对象时，新的实例对象会有一个隐性的原型属性指向这个原型对象，这就是 js 的继承机制。

### 7. 闭包

> 定义

MDN 对闭包的定义是：一个函数和对其词法环境的引用捆绑在一起，这个组合就是闭包。所以广义来讲，所有函数都是闭包。当一个函数被创建时，会保存所有的父变量对象（父变量对象层级链）到其内部属性[[scope]]中。当这个函数不在其定义的作用域中执行时，即使父函数执行上下文被销毁，仍然可以通过作用域链访问到自由变量（即外部变量），从而形成了闭包。

> 缺点

浪费内存，因为自由变量会常驻内存，使用不当会造成内存泄露。

### 8. 垃圾回收

> 定义

自动的内存管理机制，释放不用的内存。

> 方法

       1. 引用计数：使用引用表保存内存里各种资源的引用次数，如果引用次数为0则代表可以释放这块内存。
       2. 标记清除：最常用的方法，定期从全局对象window开始查找引用的对象，再找这些对象引用的对象，对活着的对象进行标记，然后清除那些没有标记的对象。

### 9. 内存泄露

> 定义

指已分配的内存由于某种原因未释放，造成内存的浪费，导致程序运行速度减慢甚至系统崩溃等后果。

> 形式

       闭包
       循环引用
       定时器
       未捕获的异常
       对DOM的引用，weakMap解决DOM引用占内存的问题

### 10. 深拷贝 浅拷贝

    > 区别

    浅拷贝复制的是对象的引用地址，结果是两个对象指向同一个地址。

    深拷贝指复制所有字段，对于引用对象会开辟新的内存来保存。

    > 方法

        1. JSON.stringify，对象中不能包含function或者RegExp
        2. 使用递归

### 11. 使用多个 icon 字体图标库

    保证每个图标库的字体命名不同。

### 12. for foreach map 区别

    [循环跳出](https://blog.csdn.net/qq_39370934/article/details/102870909)

        1. 性能上for优于foreach和map
        2. for循环无法使用return语法，会报错；使用break和continue退出循环
        3. foreach和mpa，使用break和continue会报错，使用return可跳出本次循环；使用抛错可以跳出整个循环

### 13. Promise

> 定义

Promise 是 ES6 提供的一种异步解决方案。

Promise 是一个构造函数，接受一个函数作为参数，并且传入 resolve 和 reject 两个参数。resolve 是将 Promise 状态置为 fullfilled，执行成功的回调。reject 将 Promise 状态置为 rejected，执行失败的回调。Promise 提供 then 方法，接受一个函数作为参数，并且使用调用 resolve 时的参数；提供 catch 方法，指定 reject 的回调。

> 优点

    1. 能把原来回调函数分离的写法变成链式方法调用。
    2. 把异步处理对象和规则规范化，采用统一接口来编写。
    3. 状态的固定，一旦状态发生变化，不会再变。

> 缺点

    1. 一旦新建，无法取消
    2. 无法知晓pending状态的进度
    3. 如果不设置reject回调，内部错误无法反映到外部

### 14. map set 作用

    1. 新的数据结构。
    2. Set类似于数组，但是成员值唯一。加入值的时候不会发生类型转换，NaN等于自身。
    3. Map类似于对象，键可以是任何类型的值。
    4. WeakSet和WeakMap中的对象都是弱引用，即垃圾回收机制不考虑该对象的引用。也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占的内存，不考虑该对象还是否存在其中。

### 15. react vue 数据传递方式的不同

    vue有双向数据绑定：DOM元素绑定data值，当改变时，vue的响应式机制会自动监听data的变化重新渲染。
    都是单向数据流。

### 16. cookie localstorage sessionstorage

    1. 都是前端数据存储方案，都受浏览器同源策略的保护。
    2. cookie是服务器对任意http请求发送set-cookie头作为响应的一部分，包括会话消息。
    3. Localstorage是H5提出的持久化数据保存方案。

## 3/24

### 1. 垂直居中的方法

> 子元素是块元素

1.  父元素：display:table-cell;vertical-align:middle；子元素：margin:auto
2.  父元素相对定位，子元素绝对定位（transform，-margin，margin：auto 0）
    > 子元素是行内元素
3.  父元素行高和高度保持一致
4.  父元素上下等大小的 padding，父元素无法设定高度
5.  子元素（浮动也可）相对定位，再设置垂直居中
    > 皆可
6.  父元素设为弹性盒
    > 某一个元素居中
7.  父元素 align-items：flex-start，子元素 align-self：center

### 2. this 指向

> 函数和 class 中 this 的区别
> class 函数和普通构造函数的区别

    1. class函数只能通过new调用，没有new会报错
    2. class内部定义的方法都是不可枚举的，Object.keys中不会遍历这些属性
    3. class内部默认严格模式
    4. class不存在变量提升：必须保证子类在父类之后定义
    5. Son.__proto__=Father

### 3. var a=b={x:1};a.x=a={x:1}

    ```
    var a=b={x:1} //a和b同时赋值到堆内存中A{x:1}
    a.x=a={x:1} //.操作符优先级大于=，且等号执行顺序从右向走，所以先执行a.x，即A.x。然后a重新赋值给另一个B{x:1}。再执行A.x=a得到A{x:{x:1}}
    ```

### 4. 找出一个字符串中不重复的最长子串

### 5. Hooks 解决什么问题，useEffect，哪个钩子能保证依赖更新，但是本身不更新

> 能在不使用 class 组件时使用 state、生命周期等，使用一些钩子函数引入外部功能，使用 use 开头。标志着<strong>React 中不会再存在无状态组件，只有类组件和函数组件的概念</strong>。

> class 组件的问题

    1. 需要使用super(this)
    2. this指向问题
    3. 生命周期分散相关的逻辑
    4. 不能很好的支持非可视逻辑的共享。之前可以使用高阶组件封装部分逻辑，但会导致“封装地狱”。

> 函数组件每一次渲染都有它自己的props和state。每一次渲染都有自己的事件处理函数，如果是延迟回调要考虑回调函数中捕获的props和state是否是最新的。Effects中某些异步回调执行时，即使页面已经重新渲染很多次了，但是异步回到中捕获的state和props仍然是产生这些effects的那次渲染组件中的state和props。

> useRef可用来存放可变数据，组件多次渲染时，引用地址不会。存储的值变化时，不会引起组件渲染。在react hook中类似于this一样的变量，可以保存任何东西。
> createRef每次渲染都会返回一个新引用，useRef每次都会返回相同的引用。

#### 解决闭包
1. 减少函数内部对外部变量的依赖，如使用useEffect中使用函数代替值替换
2. 使用可变数据代替不可变数据：对于非函数类型，使用useRef代替useState；对于函数类型，可通过useRef保持函数引用地址不变，在useCallback中自动捕获最新的值。

### 6. 使用 hooks 解决竞态请求（标志位）

    [通过 React Hooks 和闭包来解决请求竞态问题](https://tickrain.com/archives/347)

### 7. websocket 请求怎么建立的，丢包怎么处理

#### 定义

浏览器和服务器之间的一种全双工通信协议。最大特点是服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话。

#### 与 http 相同点

1. 都基于 tcp
2. 都使用 request/response 模型进行连接的建立
3. 建立连接过程中对错误的处理方式相同，这个阶段 ws 可能返回和 http 相同的返回码
4. 都可以在网络中传输数据

#### 与 http 不同点

1. ws 使用 http 来建立连接，借用 101 switch protocol 来达到协议转换的。ws 定义了一系列新的 header，这些 header 在 http 中不会使用
2. ws 连接不能通过中间人来转发，必须是一个直接连接
3. ws 连接建立后，通信双方可以在任何时刻向另外一方发送数据
4. ws 连接建立后，数据传输用帧来传递

### 8. 微前端

### 9.this

> this 属于运行时的概念，主要看执行环境

    1. 全局环境下的this，严格模式下指向undefined，之外指向window
    2. 上下文对象调用中的this，指向最后调用它的对象
    3. bind/call/apply改变this指向
    4. 构造函数中的this
    5. 箭头函数中的this，根据外层上下文作用域来决定
    6. 优先级：new>apply/call/bind>对象调用>全局环境调用，箭头函数的this无法改变

## 3/25

### 1.react 对比其他框架的优点，和 vue 的不同

#### 优点

    1. 速度快：UI渲染中，使用虚拟DOM的操作实现对真实DOM的局部更新
    2. 跨浏览器兼容：提供标准的api
    3. 模块化：可编写独立的模块化UI组件
    4. 单向数据流

#### 缺点

    1. 只是一个View框架，需要结合其他库如路由、状态管理等才能写大型应用
    2. 陡峭的学习曲线

#### 和 vue 的对比

> 相同

    1. 都是用于创建UI的js框架，其他功能如路由、状态管理由其他的库管理
    2. 都是基于组件的架构
    3. 都使用虚拟DOM，因为改变真实的DOM状态远比改变一个JS对象的花销要大很多

> 不同

    1. Vue中组件分全局注册和局部注册，在react中只有通过import引入来使用
    2. 模板渲染方式不同：vue通过一种扩展的HTML语法进行渲染，react使用jsx来渲染模板。
    3. 监听数据变化的实现原理不同：vue通过getter/setter和一些函数的劫持来了解数据的变化；react是通过调用setState和diff算法来计算数据的变化。
    4. 数据流的不同：react提倡单向数据流，vue通过v-model实现双向绑定，其他也是单向数据流。
    5. 组件通信的不同：vue中三种组件通信的方式：父组件通过props传递数据、子组件通过事件向父组件发送消息、provide/inject可以实现跨层级注入数据；react中三种通信方式：props、context实现跨层级通信、回调函数。

#### 虚拟 DOM

    不是真实的DOM，不需要浏览器的api支持。是在DOM基础上建立的一个抽象层，实质是一个JavaScript对象，当数据和状态发生变化，都会自动高效地同步到虚拟DOM中，最后再将变化的部分同步到DOM中。

#### 父组件更新，子组件未引用 props 是否更新

    会更新。如果是class组件，1).可以在shouldComponentUpdate方法中对比props和state来决定是否渲染，2).可以使用React.PureComponent；如果是函数组件，1).使用React.memo包裹组件，2).React.useMemo，3).使用React.useCallback保存函数形式的props

#### setState 是否同步更新

    由React控制的事件处理过程setState不会同步更新this.state，一般组件中的绑定方法都经过React包装，所以都是以异步的方式执行；
    在React控制之外的情况（脱离React的上下文时），如果直接绑定DOM、定时器事件中，setState会同步更新this.state

### 2.react 中 hooks 的作用

React 函数组件引入副作用的解决方案。函数组件的主体只用来返回 html 的代码，所有副作用都通过钩子引入。

> 纯函数

只进行单纯的数据计算的函数，在函数式编程里称为“纯函数”。

> 副作用

函数式编程中，将那些与计算无关的操作都称为“副作用”。如果函数内部直接包含产生副作用的操作，就不是纯函数了。

### 3.用 hooks 实现 componentDidUpdate

使用 useEffect，只传第一个参数。此时等于 componentDidMount+componentDidUpdate 的效果。再通过 userRef 增加一个 flag 去判断是否属于初次渲染。

### 4.useEffect 返回值的作用

effect 可选的清除机制。
React 会在组件卸载的时候执行清除操作。
effect 会在每次执行前对上一个 effect 进行清除。

> useEffect包裹的函数执行脱离了函数组件本身的执行上下文，所以不会对函数组件本身的执行造成影响。

### 5.HTML 的渲染过程

    1. 构建DOM树。将html解析成DOM树。
    2. 构建css规则树。浏览器将css解析成CSSOM树。
    3. 将DOM树和CSSOM合并形成Render树。
    4. 布局：对Render树中的每个节点进行布局，计算大小、位置等。
    5. 绘制。根据计算出的规则，将内容绘制在屏幕上。

> 回流

回流是当某个位置的布局发生了变化，浏览器会重新从根据开始计算该节点的布局。

### 6.css 中选择器优先级

指给 HTML 元素应用样式时，如果有多个 css 选择器同时指向此元素，那么优先级最高的选择器会最终应用到此元素上。
优先级是通过计算权重来得到的，从高到低分为五个级别，为：

- 4. style 行内样式
- 3. ID 选择器
- 2. class、属性和伪类选择器
- 1. 标签和伪元素选择器
- 0. 通配符（\*）、选择符（+>~||）、逻辑组合伪类（:not()、is()、:where），不计算权重

只有前四个级别计算权重。使用一组向量标志(0,0,0,0)来表示，如果某个级别如果有选择器，则对应位置的向量+1，最终逐级比较高位数字，选择采用最大的那个。当遇到!important 的样式直接采用，如果权重相同使用最后一个类选择器。

### 7.相对于 div，使用原生 button 元素的优势

1. button 支持禁用（表单元素的通性），直接设置 disabled 属性可以达到禁用的效果，包括鼠标和键盘的禁用。可通过:disabled 伪类来改变禁用的样式。父级元素的禁用可应用到 button 上。
2. 默认盒子属性是 border-box，垂直水平居中。
3. 支持键盘访问。使用 tab 键进行焦点切换时有明显的焦点提示（outline），聚焦状态下可通过 enter 或 space 键触发点击事件。
4. 具备表单特性。type='submit'天然支持表单提交，触发 form 的 submit 事件，支持回车登录。type='reset'支持表单的重置。
5. 支持屏幕阅读访问。配合浏览器的 web accessibility

> 不使用的原因

1. 在各浏览器样式表现不一致
2. 不能包含含交互内容的标签，如 a 标签

[使用 button 的 5 个理由](https://segmentfault.com/a/1190000041069149)

### 8.webpack 中怎么优化大文件


## 03/29
### 1. 为什么选择redux，redux有哪些优缺点
#### 优点
1. 便于调试
2. 便于线上错误手机，只要发送states，actions等快照即可
3. 结合localStoreage可初始化store
4. 便于服务端渲染
5. 时光旅行undo/redo，每次都使用新的state，相当于为state生成了很多的快照，有回溯能力

#### 缺点
1. redux只支持同步处理以达到Pure的目的，没有内置的副作用处理方式，所以需要结合中间件来处理函数。
2. 重复的模板代码，冗余太多，一个功能需要些reducer和action和actionType。同一个逻辑分散在多处。
3. 性能问题。每次action会触发所有reducer的处理；每次state变化会导致所有connect的组件重新执行mapStateToProps，若没有对props的修改进行判断和拦截会触发大量的组件重新render。
### 2. redux怎么做优化
1. SPA中只有跨页面的信息才进入Store。基于这个原则，对Store进行精简、降级，需要多维度共享且数据源变更频繁的数据建议redux处理。
2. 可以使用redux-ignore，防止触发跟某个reducer无关的action。
3. redux/toolkit concent/recoil redux + redux-thunk/redux-saga/redux-observable + reselect/immer
### 3. baseModel：code generator
### 4. es Module和commonJS的区别
#### 问题
1. 命名冲突。可通过自执行函数解决。
2. 文件依赖。多文件引入会引起顺序冲突。
#### 解决的问题
1. 每个文件都是独立的作用域，保证了模块代码安全，不存在变量污染。
2. 暴露接口。不添加全局变量。
3. 依赖顺序管理。
#### 区别
> CommonJS输入的是一个值的拷贝，ES Module输出的是值的引用。
> CommonJS是运行时加载，ES Module是编译时输出接口。

CommonJs模块是对象，运行时加载，运行时才把模块挂载在exports上（加载整个模块的所有），加载模块其实就是查找对象属性。
ES Module不是对象，使用export显式指定输出，再通过import输入；为编译时加载，编译时遇到import会生成一个只读引用，等到运行时会根据此引用去加载的模块取值，所以不会加载模块所有方法。

> CommonJs模块的require()是同步加载模块，ES Module的import命令是异步加载，有一个独立的模块依赖的解析阶段。
### 5. 虚拟DOM一定会快吗
1. 虽然操作DOM会引起页面的回流和重绘，但是虚拟DOM不一定比原生DOM操作快。因为虚拟DOM是另外维护了一层js对象树，所有操作都要先计算虚拟DOM的变化后再去操作真实的DOM。而且复杂情况下浏览器会对我们的DOM操作进行优化，会根据我们操作的时间和此时进行批量处理，所以直接操作DOM也未必慢。
2. 使用虚拟DOM可以提高代码的性能下限，并极大的优化大量操作DOM时产生的性能损耗。这些框架能保证即使虚拟DOM不太给力的情况下，性能也在我们能接受的范围内。
3. 虚拟DOM的真正价值在于：1）为函数式UI编程打开了大门；2）可以渲染到DOM以外的环境中。
### 6. react的Diff？如果子元素的keyList由[1,2,3,4]变成[1,3,2,4]，是怎么计算的？
> React Diff的两个前提：
1. 两个不同类型的元素会产生不同的树。
2. 通过附带的key属性，开发者可以示意哪些元素是稳定的。

> 数组的比较（[React列表diff原理](https://github.com/phenomLi/Blog/issues/24)）
采用最右访问位置法。即遍历新数组，如果当前访问的元素存在于旧数组中，那么比较这个元素的在旧数组中的下标是否比之前访问过的所有元素在旧数组的下标的最大值（最靠右，默认为0，每遍历一个元素就要更新这个值）要小，那么这个元素就要移动；如果当前元素不存在与旧数组中，就判断该元素需要插入。遍历完成新数组后，再遍历一次旧数组，发现某个元素不存在于新数组中，就判断该元素要删除。

### 7. 怎么部署前端？如果本地编译没有问题，线上编译出错，要怎么排查问题？前端有没有自动化监控？
### 8. forEach能等待异步函数执行吗
### 9. Promise的限流
### 10. Promise实现retry
### 11. baseFetch中怎么处理重复请求的问题

## 04/17
### 1.LCM介绍
### 2.Hooks作用
### 3.巡检功能介绍
### 4.微电商平台的技术选型过程，比较的维度
### 5.首页改版的过程及技术难点
### 6.项目的业务指标，如PU等
### 7.useMemo的实现
### 8.Promise.all