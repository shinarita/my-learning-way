# 记录我的面试

### 3/17
1. 微前端
   目的：云计算项目中各种组件的迭代版本不一致；POC项目，客户定制化版本的需要。

   思想：微前端思想来源于微服务，将一个大的应用拆分成不同的子应用，子应用可以独立开发、独立部署，可使用不同的技术栈。单页面应用中，会维护一张路由注册表，每个路由对应页面组件的url。切换路由时，如果是新页面则动态获取路由对应的js脚本并执行渲染；如果是已访问过，则从缓存中获取已缓存的页面方法，执行并渲染。

   single-spa应用分为两类：基座应用和子应用。基座应用会维护一个路由注册表，每个路由对应一个子应用。切换路由就会动态渲染对应的子应用。

   >需要的工作：

        1. 改造项目，增加基座应用，维护路由。
        2. 改造子项目，增加生命周期函数bootstrap、mount、unmount。
    
   > 我的工作：

       1. 合并login模块，改造login模块，增加启动、卸载等方法，保存登录态。
       2. 使用nodejs编写自动化按需构建脚本，可以选择需要打包的子应用。
       3. 开发自定义loader。
   
   > iframe缺点

       1. 用户体验不好，切换应用时浏览器需重新加载页面
       2. UI不同步，DOM结构不共享，浏览器状态不一致
       3. 全局上下文完全隔离，通信不同步
   > qiankun的缺点，可以独立打包一些类库吗。相比iframe的缺点<br>

       1.相同的资源重复加载
       2.启动应用时必须要启动基座应用
2. 跨域
   > 定义  

   指浏览器遵循同源策略，限制脚本内发起的跨域http请求，具体指域名、协议、端口号完全相同才是同源。
   > 方法

       1. jsonp，缺点是只能get，易受到xss攻击
       2. CORS，跨域资源共享。跨域请求时浏览器会带上origin请求头，后端接收后会加上access-control-allow-origin，浏览器会判断是否继续响应。缺点：忽略cookie。简单请求直接发送，非简单请求会先使用options方法发送一个预检请求，符合条件后再发送正式请求。
       3. nginx反向代理
3. http code

       1. 100：continue，继续请求
       2. 101：切换协议，如http新版本、websocket
       3. 200：ok
       4. 301：永久移动，会返回新的url
       5. 304：未修改
       6. 400：语法错误
       7. 401：未授权
       8. 403：拒绝服务
       9. 404：未找到
       10. 500：服务器内部错误
       11. 502：网关错误
       12. 503：服务不可用
       13. 504：网关超时
4. websocke协议
   > 定义

   因为http单向请求的特点，一般通过轮询来连续获取服务端的信息。而websocket是H5的一种新协议，实现浏览器和客户端全双工通信，同时允许跨域通信。
   > 与http关系

       1. 也建立在tcp协议之上。
       2. 与http有良好的兼容性，默认端口也是80和443，握手阶段采取http协议，因此不容易被屏蔽，能通过各种http代理服务器。
       3. 没有同源限制，可与任务服务器通信。
       4. 加密使用wss协议标识符，服务器网址就是url
5. metadata

   元数据，提供关于页面的元数据。在html中处于head区域，用于页面的说明、关键字和其他元数据。有name、http-equiv、content、scheme属性，name指定meta元素的类型，content指定实际内容。一般有keywords、description、author、viewport、robots、copyright。
6. 原型
   > 定义

   js是一种基于原型的语言，是指每个对象都有一个原型对象。对象以原型对象为模板，继承方法和属性。原型对象也可以拥有原型，并继承属性和方法，一层一层直到Object.prototype，这就是原型链。当我们查找一个对象的属性时，首先查找本身，如果没有，就顺着原型链查找其原型对象上的属性，如果最终没有就是undefined。
   js中每个函数都有prototype这个属性，当作为构造函数创建新对象时，新的实例对象会有一个隐性的原型属性指向这个原型对象，这就是js的继承机制。
7. 闭包
   > 定义

   MDN对闭包的定义是：一个函数和对其词法环境的引用捆绑在一起，这个组合就是闭包。所以广义来讲，所有函数都是闭包。当一个函数被创建时，会保存所有的父变量对象（父变量对象层级链）到其内部属性[[scope]]中。当这个函数不在其定义的作用域中执行时，即使父函数执行上下文被销毁，仍然可以通过作用域链访问到自由变量（即外部变量），从而形成了闭包。
   > 缺点

   浪费内存，因为自由变量会常驻内存，使用不当会造成内存泄露。
8. 垃圾回收
   > 定义

   自动的内存管理机制，释放不用的内存。
   > 方法

       1. 引用计数：使用引用表保存内存里各种资源的引用次数，如果引用次数为0则代表可以释放这块内存。
       2. 标记清除：最常用的方法，定期从全局对象window开始查找引用的对象，再找这些对象引用的对象，对活着的对象进行标记，然后清除那些没有标记的对象。

9. 内存泄露
   > 定义

   指已分配的内存由于某种原因未释放，造成内存的浪费，导致程序运行速度减慢甚至系统崩溃等后果。
   > 形式

       闭包
       循环引用
       定时器
       未捕获的异常
       对DOM的引用，weakMap解决DOM引用占内存的问题
10. 深拷贝 浅拷贝
    > 区别

    浅拷贝复制的是对象的引用地址，结果是两个对象指向同一个地址。

    深拷贝指复制所有字段，对于引用对象会开辟新的内存来保存。

    > 方法

        1. JSON.stringify，对象中不能包含function或者RegExp
        2. 使用递归
11. 使用多个icon字体图标库

    保证每个图标库的字体命名不同。
12. for foreach map区别

    [循环跳出](https://blog.csdn.net/qq_39370934/article/details/102870909)

        1. 性能上for优于foreach和map
        2. for循环无法使用return语法，会报错；使用break和continue退出循环
        3. foreach和mpa，使用break和continue会报错，使用return可跳出本次循环；使用抛错可以跳出整个循环
13. Promise
   > 定义

  Promise是ES6提供的一种异步解决方案。
  
  Promise是一个构造函数，接受一个函数作为参数，并且传入resolve和reject两个参数。resolve是将Promise状态置为fullfilled，执行成功的回调。reject将Promise状态置为rejected，执行失败的回调。Promise提供then方法，接受一个函数作为参数，并且使用调用resolve时的参数；提供catch方法，指定reject的回调。
  > 优点

    1. 能把原来回调函数分离的写法变成链式方法调用。
    2. 把异步处理对象和规则规范化，采用统一接口来编写。
    3. 状态的固定，一旦状态发生变化，不会再变。
  > 缺点

    1. 一旦新建，无法取消
    2. 无法知晓pending状态的进度
    3. 如果不设置reject回调，内部错误无法反映到外部
14. map set 作用

    1. 新的数据结构。
    2. Set类似于数组，但是成员值唯一。加入值的时候不会发生类型转换，NaN等于自身。
    3. Map类似于对象，键可以是任何类型的值。
    4. WeakSet和WeakMap中的对象都是弱引用，即垃圾回收机制不考虑该对象的引用。也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占的内存，不考虑该对象还是否存在其中。
15. react vue 数据传递方式的不同
    vue有双向数据绑定：DOM元素绑定data值，当改变时，vue的响应式机制会自动监听data的变化重新渲染。
    都是单向数据流。
16. cookie localstorage sessionstorage
    1. 都是前端数据存储方案，都受浏览器同源策略的保护。
    2. cookie是服务器对任意http请求发送set-cookie头作为响应的一部分，包括会话消息。
    3. Localstorage是H5提出的持久化数据保存方案。

### 3/24
1. 垂直居中的方法
> 某一个元素居中
2. this指向
> 函数和class中this的区别
3. var a=b={x:1};a.x=a={x:1}
4. 找出一个字符串中不重复的最长子串
5. Hooks解决什么问题，useEffect，哪个钩子能保证依赖更新，但是本身不更新
6. 使用hooks解决竞态请求（标志位）
7. websocket请求怎么建立的，丢包怎么处理
8. 微前端